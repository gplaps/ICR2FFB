#include <windows.h>
#include <dinput.h>
#include <iostream>
#include <fstream>
#include <string>
#include <thread>
#include <algorithm>
#include "json.hpp"
#include <atomic>
#include <mutex>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

struct TelemetryDisplayData {
    double dlat = 0.0;
    double dlong = 0.0;
    double rotation_deg = 0.0;
    double slipAngleDeg = 0.0;
    int forceMagnitude = 0;
    int directionVal = 0;
};

std::mutex displayMutex;
TelemetryDisplayData displayData;

std::atomic<double> currentSpeed = 0.0;
using json = nlohmann::json;

int centeringStrength = 0;
int currentAppliedGain = -1; // will store last applied spring gain
IDirectInputEffect* springEffect = nullptr; // persistent handle to the spring

IDirectInputEffect* slipForceEffect = nullptr;

LPDIRECTINPUTEFFECT damperEffect = nullptr;
int currentDamperGain = -1;
bool damperActive = false;

LPDIRECTINPUT8 directInput = nullptr;
IDirectInputDevice8* matchedDevice = nullptr;
std::wstring targetDeviceName;

// Callback to find matching device and create it
BOOL CALLBACK EnumDevicesCallback(const DIDEVICEINSTANCE* pdidInstance, VOID* pContext) {
    if (pdidInstance->tszProductName == targetDeviceName) {
        std::wcout << L"Matched Device: " << pdidInstance->tszProductName << std::endl;

        HRESULT hr = directInput->CreateDevice(pdidInstance->guidInstance, &matchedDevice, nullptr);
        if (FAILED(hr)) {
            std::wcerr << L"Failed to create device interface." << std::endl;
        }
        return DIENUM_STOP; // Stop after finding the match
    }
    return DIENUM_CONTINUE;
}

BOOL CALLBACK EnumEffectsCallback(LPCDIEFFECTINFO pei, LPVOID pvRef) {
    std::wcout << L"Supported Effect: " << pei->tszName << std::endl;
    return DIENUM_CONTINUE;
}

bool LoadFFBSettings(const std::wstring& filename) {
    std::wifstream file(filename);
    if (!file) {
        std::wcerr << L"Failed to open " << filename << std::endl;
        return false;
    }

    std::wstring line;
    while (std::getline(file, line)) {
        if (line.rfind(L"Device: ", 0) == 0) {
            targetDeviceName = line.substr(8);
        }
        else if (line.rfind(L"Centering: ", 0) == 0) {
            centeringStrength = std::stoi(line.substr(11));
        }
    }

    if (targetDeviceName.empty()) {
        std::wcerr << L"No 'Device: ' entry found." << std::endl;
        return false;
    }

    return true;
}

void UpdateDamperEffect(double speed) {
    return;
    if (!matchedDevice) return;

    // Create the effect once
    if (!damperEffect) {
        matchedDevice->Acquire();

        DIPROPRANGE diprg = {};
        diprg.diph.dwSize = sizeof(DIPROPRANGE);
        diprg.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        diprg.diph.dwHow = DIPH_BYOFFSET;
        diprg.diph.dwObj = DIJOFS_X;
        diprg.lMin = -10000;
        diprg.lMax = 10000;
        matchedDevice->SetProperty(DIPROP_RANGE, &diprg.diph);

        DICONDITION damperCondition = {};
        damperCondition.lOffset = 0;
        damperCondition.lPositiveCoefficient = 10000;
        damperCondition.lNegativeCoefficient = 10000;
        damperCondition.lDeadBand = 0;

        DWORD axes[1] = { DIJOFS_X };
        LONG directions[1] = { 0 };

        DIEFFECT eff = {};
        eff.dwSize = sizeof(DIEFFECT);
        eff.dwFlags = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS;
        eff.dwDuration = INFINITE;
        eff.dwGain = 10000;
        eff.dwTriggerButton = DIEB_NOTRIGGER;
        eff.cAxes = 1;
        eff.rgdwAxes = axes;
        eff.rglDirection = directions;
        eff.cbTypeSpecificParams = sizeof(DICONDITION);
        eff.lpvTypeSpecificParams = &damperCondition;

        HRESULT hr = matchedDevice->CreateEffect(GUID_Damper, &eff, &damperEffect, NULL);
        if (SUCCEEDED(hr)) {
            damperEffect->Start(INFINITE, 0);
            std::wcout << L"Damper effect created and started\n";
        }
        else {
            std::wcerr << L"Failed to create damper effect. HRESULT = 0x" << std::hex << hr << std::endl;
            return;
        }
    }

    // Compute dynamic damper gain
    int gainPct;
    if (speed <= 10.0) {
        gainPct = 100;
    }
    else if (speed >= 50.0) {
        gainPct = 0;
    }
    else {
        double t = (speed - 10.0) / (50.0 - 10.0);  // 0 at 10mph, 1 at 50mph
        gainPct = static_cast<int>((1.0 - t) * 100.0);
    }

    int newGain = gainPct * 100;
    if (newGain == currentDamperGain) return;
    currentDamperGain = newGain;

    // Update the effect
    DIEFFECT eff = {};
    eff.dwSize = sizeof(DIEFFECT);
    eff.dwGain = newGain;

    HRESULT hr = damperEffect->SetParameters(&eff, DIEP_GAIN);
    if (SUCCEEDED(hr)) {
        std::wcout << L"Damper gain updated: " << newGain << std::endl;
    }
    else {
        std::wcerr << L"Damper gain update failed. HRESULT = 0x" << std::hex << hr << std::endl;
    }
}

void TelemetryLoop() {
    static double prev_dlat = 0.0;
    static double prev_dlong = 0.0;
    static bool first_reading = true;

    while (true) {
        try {
            std::ifstream file("telemetry_output.json");
            if (file) {
                json j;
                file >> j;

                if (j.contains("speed_mph")) {
                    currentSpeed = j["speed_mph"];
                }

                if (j.contains("dlat") && j.contains("dlong") && j.contains("rotation_deg")) {
                    double dlat = j["dlat"];
                    double dlong = j["dlong"];
                    double rotation_deg = j["rotation_deg"];

                    // Suppress DLONG wraparound spike (e.g., crossing start/finish line)
                    bool suppressFrame = false;
                    if (!first_reading && prev_dlong > 8000.0 && dlong < 1000.0) {
                        suppressFrame = true;
                        std::wcout << L"[Slip Calc] Suppressed DLONG wraparound: prev=" << prev_dlong << L", curr=" << dlong << std::endl;
                    }

                    double slipAngle = 0.0;

                    if (!first_reading && !suppressFrame) {
                        // Calculate raw deltas
                        double delta_lat = dlat - prev_dlat;
                        double delta_long = dlong - prev_dlong;

                        // If delta_long is absurdly large, skip the frame entirely
                        bool validDelta = std::abs(delta_long) <= 10000000.0;
                        if (!validDelta) {
                            std::wcout << L"[Slip Calc] Ignored large DLONG delta: " << delta_long << std::endl;
                        }

                        if (validDelta && currentSpeed > 0.5 && (std::abs(delta_lat) > 1e-6 || std::abs(delta_long) > 1e-6)) {
                            double movementAngle = atan2(delta_lat, delta_long);
                            double headingAngle = rotation_deg * (M_PI / 180.0);
                            slipAngle = movementAngle - headingAngle;

                            // Normalize to [-Ï€, Ï€]
                            while (slipAngle > M_PI) slipAngle -= 2 * M_PI;
                            while (slipAngle < -M_PI) slipAngle += 2 * M_PI;
                        }
                    }
                    else {
                        first_reading = false;
                    }

                    // Only update prev values if not suppressing
                    if (!suppressFrame) {
                        prev_dlat = dlat;
                        prev_dlong = dlong;
                    }


                    double absSlipDeg = std::abs(slipAngle * 180.0 / M_PI);
                    double speed = currentSpeed.load();
                    double slipScale = 1.0;

                    // Apply taper from 0 to 1 between 20mph and 40mph
                    if (speed < 20.0) {
                        slipScale = 0.0;
                    }
                    else if (speed < 40.0) {
                        slipScale = (speed - 20.0) / 20.0;
                    }

                    // Scale the force by slip angle and speed
                    int forceMagnitude = static_cast<int>(
                        std::clamp(absSlipDeg * 400 * slipScale, 0.0, 10000.0)
                        );

                    LONG slipDirection = (slipAngle > 0) ? 1 : (slipAngle < 0 ? -1 : 0);

                    if (slipForceEffect) {
                        double forceFraction = 0.0;

                        if (absSlipDeg < 0.001) {
                            forceFraction = 0.0;
                        }
                        else if (absSlipDeg < 2.0) {
                            // Ramp from 0.001 to 2.0 â†’ 0% to 25%
                            forceFraction = ((absSlipDeg - 0.001) / (2.0 - 0.001)) * 0.25;
                        }
                        else if (absSlipDeg < 10.0) {
                            // Ramp from 2.0 to 10.0 â†’ 25% to 50%
                            forceFraction = 0.25 + ((absSlipDeg - 2.0) / (10.0 - 2.0)) * 0.25;
                        }
                        else {
                            // Cap at 50%
                            forceFraction = 0.50;
                        }

                        int magnitude = static_cast<int>(std::clamp(forceFraction * 10000.0, 0.0, 10000.0));


                        LONG directionVal = (slipAngle > 0) ? 10000 : (slipAngle < 0 ? -10000 : 0);

                        // Always stop effect before changing parameters
                        slipForceEffect->Stop();

                        DICONSTANTFORCE cf = {};
                        cf.lMagnitude = magnitude;

                        DIEFFECT eff = {};
                        eff.dwSize = sizeof(DIEFFECT);
                        eff.dwFlags = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS;
                        eff.dwDuration = INFINITE;
                        eff.dwGain = 10000;
                        eff.dwTriggerButton = DIEB_NOTRIGGER;
                        eff.cAxes = 1;
                        DWORD axes[1] = { DIJOFS_X };
                        LONG dir[1] = { directionVal };
                        eff.rgdwAxes = axes;
                        eff.rglDirection = dir;
                        eff.cbTypeSpecificParams = sizeof(DICONSTANTFORCE);
                        eff.lpvTypeSpecificParams = &cf;

                        HRESULT hr = slipForceEffect->SetParameters(
                            &eff,
                            DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_DURATION
                        );

                        if (FAILED(hr)) {
                            std::wcerr << L"Slip force SetParameters failed: 0x" << std::hex << hr << std::endl;
                        }

                        // Always start the effect after setting it
                        hr = slipForceEffect->Start(1, DIES_SOLO);
                        if (FAILED(hr)) {
                            std::wcerr << L"Slip force Start failed: 0x" << std::hex << hr << std::endl;
                        }
                    }
                    {
                        std::lock_guard<std::mutex> lock(displayMutex);
                        displayData.dlat = dlat;
                        displayData.dlong = dlong;
                        displayData.rotation_deg = rotation_deg;
                        displayData.slipAngleDeg = slipAngle * 180.0 / M_PI;
                        displayData.forceMagnitude = forceMagnitude;
                        displayData.directionVal = (slipAngle > 0) ? -10000 : (slipAngle < 0 ? 10000 : 0);
                    }
                }
            }
        }
        catch (const std::exception& ex) {
            std::wcerr << L"Telemetry read error: " << ex.what() << std::endl;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void ApplyCenteringSpring() {
    return;
    if (!matchedDevice) return;

    double speed = currentSpeed.load();

    int dynamicGainPct;

    if (speed <= 10.0) {
        dynamicGainPct = 0;
    }
    else if (speed >= 100.0) {
        dynamicGainPct = 100;
    }
    else {
        double t = (speed - 10.0) / (100.0 - 10.0); // normalized from 0 to 1
        dynamicGainPct = static_cast<int>((1.0 - t) * centeringStrength + t * 100.0);
    }

    int newGain = std::clamp(dynamicGainPct * 100, 0, 10000);
    if (newGain == currentAppliedGain) return;

    currentAppliedGain = newGain;

    // Build new effect parameters
    DICONDITION springCondition = {};
    springCondition.lOffset = 0;
    springCondition.lPositiveCoefficient = 10000;
    springCondition.lNegativeCoefficient = 10000;
    springCondition.lDeadBand = 0;

    DWORD axes[1] = { DIJOFS_X };
    LONG direction[1] = { 0 };

    DIEFFECT eff = {};
    eff.dwSize = sizeof(DIEFFECT);
    eff.dwFlags = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS;
    eff.dwDuration = INFINITE;
    eff.dwGain = newGain;
    eff.dwTriggerButton = DIEB_NOTRIGGER;
    eff.cAxes = 1;
    eff.rgdwAxes = axes;
    eff.rglDirection = direction;
    eff.cbTypeSpecificParams = sizeof(DICONDITION);
    eff.lpvTypeSpecificParams = &springCondition;

    if (!springEffect) {
        matchedDevice->Acquire();

        DIPROPRANGE diprg = {};
        diprg.diph.dwSize = sizeof(DIPROPRANGE);
        diprg.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        diprg.diph.dwHow = DIPH_BYOFFSET;
        diprg.diph.dwObj = DIJOFS_X;
        diprg.lMin = -10000;
        diprg.lMax = 10000;
        matchedDevice->SetProperty(DIPROP_RANGE, &diprg.diph);

        HRESULT hr = matchedDevice->CreateEffect(GUID_Spring, &eff, &springEffect, NULL);
        if (SUCCEEDED(hr)) {
            springEffect->Start(INFINITE, 0);
            std::wcout << L"Spring created. Gain = " << newGain << std::endl;
        }
        else {
            std::wcerr << L"Spring creation failed: HRESULT = 0x" << std::hex << hr << std::endl;
        }
    }
    else {
        HRESULT hr = springEffect->SetParameters(&eff, DIEP_GAIN);
        if (SUCCEEDED(hr)) {
            std::wcout << L"Spring gain updated: " << newGain << std::endl;
        }
        else {
            std::wcerr << L"Spring gain update failed: HRESULT = 0x" << std::hex << hr << std::endl;
        }
    }
    if (speed < 50.0) {
        UpdateDamperEffect(speed);

        if (damperEffect && !damperActive) {
            HRESULT hr = damperEffect->Start(INFINITE, 0);
            if (SUCCEEDED(hr)) {
                damperActive = true;
                std::wcout << L"Damper started\n";
            }
        }
    }
    else {
        if (damperEffect && damperActive) {
            damperEffect->Stop();
            damperActive = false;
            std::wcout << L"Damper stopped\n";
        }
    }
}

void CreateSlipForceEffect(LPDIRECTINPUTDEVICE8 device) {
    if (!device) return;

    DICONSTANTFORCE cf = { 0 };

    DIEFFECT eff = {};
    eff.dwSize = sizeof(DIEFFECT);
    eff.dwFlags = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS;
    eff.dwDuration = INFINITE;
    eff.dwGain = 10000;
    eff.dwTriggerButton = DIEB_NOTRIGGER;
    eff.cAxes = 1;
    DWORD axes[1] = { DIJOFS_X };
    LONG dir[1] = { 0 };
    eff.rgdwAxes = axes;
    eff.rglDirection = dir;
    eff.cbTypeSpecificParams = sizeof(DICONSTANTFORCE);
    eff.lpvTypeSpecificParams = &cf;

    HRESULT hr = device->CreateEffect(GUID_ConstantForce, &eff, &slipForceEffect, NULL);
    if (FAILED(hr)) {
        std::wcerr << L"Failed to create slip force effect. HRESULT: 0x" << std::hex << hr << std::endl;
    }
}

void SpringUpdaterLoop() {
    while (true) {
        ApplyCenteringSpring();
        std::this_thread::sleep_for(std::chrono::milliseconds(250));
    }
}

void PollDeviceLoop() {
    DIJOYSTATE2 js;
    ZeroMemory(&js, sizeof(js));

    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hConsole, &csbi);

    while (true) {
        HRESULT hr = matchedDevice->Poll();
        if (FAILED(hr)) {
            matchedDevice->Acquire();
            continue;
        }

        CreateSlipForceEffect(matchedDevice);
        hr = matchedDevice->GetDeviceState(sizeof(DIJOYSTATE2), &js);
        if (FAILED(hr)) continue;

        // Clear the console screen first
        COORD topLeft = { 0, 0 };
        DWORD written, cells = csbi.dwSize.X * csbi.dwSize.Y;
        FillConsoleOutputCharacter(hConsole, L' ', cells, topLeft, &written);
        FillConsoleOutputAttribute(hConsole, csbi.wAttributes, cells, topLeft, &written);
        SetConsoleCursorPosition(hConsole, topLeft);

        // Print new output
        std::wcout << L"Device: " << targetDeviceName << L"\n";
        std::wcout << L"X: " << js.lX << L"\n";
        std::wcout << L"Y: " << js.lY << L"\n";

        {
            std::lock_guard<std::mutex> lock(displayMutex);
            std::wcout << L"Speed (MPH): " << currentSpeed.load() << L"\n";
            std::wcout << L"dLat: " << displayData.dlat << L"    dLong: " << displayData.dlong << L"\n";
            std::wcout << L"Rot: " << displayData.rotation_deg << L"Â°    ";
            std::wcout << L"Slip: " << displayData.slipAngleDeg << L"Â°    ";
            std::wcout << L"Force: " << displayData.forceMagnitude << L"    ";
            std::wcout << L"Dir: " << displayData.directionVal << L"\n";
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main() {

    std::thread springThread(SpringUpdaterLoop);
    springThread.detach();

    std::thread telemetryThread(TelemetryLoop);
    telemetryThread.detach();
    
    if (!LoadFFBSettings(L"ffb.ini")) return 1;

    HRESULT hr = DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8, (VOID**)&directInput, NULL);
    if (FAILED(hr)) {
        std::cerr << "Failed to initialize DirectInput" << std::endl;
        return 1;
    }

    hr = directInput->EnumDevices(DI8DEVCLASS_GAMECTRL, EnumDevicesCallback, NULL, DIEDFL_ATTACHEDONLY);
    if (FAILED(hr) || !matchedDevice) {
        std::cerr << "Matching device not found or failed to create." << std::endl;
        return 1;
    }


    matchedDevice->SetDataFormat(&c_dfDIJoystick2);
    matchedDevice->SetCooperativeLevel(GetConsoleWindow(), DISCL_BACKGROUND | DISCL_EXCLUSIVE);
    matchedDevice->Acquire();
    matchedDevice->EnumEffects(EnumEffectsCallback, NULL, DIEFT_ALL);
    ApplyCenteringSpring();  // ðŸ’¥ Call the spring effect here
    PollDeviceLoop();

    matchedDevice->Unacquire();
    matchedDevice->Release();
    directInput->Release();

    return 0;
}